"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SteammContract = void 0;
const base_1 = require("../base");
const utils_1 = require("@mysten/sui/utils");
const sui_1 = require("../../../utils/sui");
class SteammContract extends base_1.BaseContract {
    swap(tx) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.cpmmSwap(tx);
        });
    }
    cpmmSwap(tx) {
        const extra = this.swapInfo.extra;
        if (!extra ||
            !extra.bankAStructTag ||
            !extra.bankBStructTag ||
            !extra.poolStructTag ||
            !extra.bankA ||
            !extra.bankB ||
            !extra.lendingMarketA ||
            !extra.lendingMarketB) {
            throw new Error(`Invalid extra info for cpmmSwap`);
        }
        // the pool script v1 only support same lending market
        if (extra.lendingMarketA !== extra.lendingMarketB) {
            throw new Error(`Invalid lending market for cpmmSwap`);
        }
        const [btokenA, bTokenB, _quoter, lp] = (0, utils_1.parseStructTag)(extra.poolStructTag).typeParams;
        const [lendingMarket, coinTypeA, _bTokenA] = (0, utils_1.parseStructTag)(extra.bankAStructTag).typeParams;
        const [_lendingMarket, coinTypeB, _bTokenB] = (0, utils_1.parseStructTag)(extra.bankBStructTag).typeParams;
        const xToY = this.swapInfo.swapXtoY;
        const coinA = xToY
            ? this.inputCoinObject
            : sui_1.SuiUtils.zeroCoin(tx, (0, utils_1.normalizeStructTag)(coinTypeA));
        const coinB = !xToY
            ? this.inputCoinObject
            : sui_1.SuiUtils.zeroCoin(tx, (0, utils_1.normalizeStructTag)(coinTypeB));
        tx.moveCall({
            target: `${this.config.steamm.script}::pool_script::cpmm_swap`,
            typeArguments: [
                lendingMarket,
                coinTypeA,
                coinTypeB,
                btokenA,
                bTokenB,
                lp,
            ].map(utils_1.normalizeStructTag),
            arguments: [
                tx.object(this.swapInfo.poolId),
                tx.object(extra.bankA),
                tx.object(extra.bankB),
                tx.object(extra.lendingMarketA),
                coinA,
                coinB,
                tx.pure.bool(xToY),
                this.getInputCoinValue(tx),
                tx.pure.u64(0),
                tx.object(utils_1.SUI_CLOCK_OBJECT_ID),
            ],
        });
        const coinIn = xToY ? coinA : coinB;
        const coinOut = xToY ? coinB : coinA;
        sui_1.SuiUtils.transferOrDestroyZeroCoin(tx, this.swapInfo.assetIn, coinIn, this.currentAccount);
        return coinOut;
    }
    cpmmSwapV2(tx) {
        const extra = this.swapInfo.extra;
        if (!extra ||
            !extra.bankAStructTag ||
            !extra.bankBStructTag ||
            !extra.poolStructTag ||
            !extra.bankA ||
            !extra.bankB ||
            !extra.lendingMarketA ||
            !extra.lendingMarketB) {
            throw new Error(`Invalid extra info for cpmmSwap`);
        }
        // the pool script v1 only support same lending market
        if (extra.lendingMarketA !== extra.lendingMarketB) {
            throw new Error(`Invalid lending market for cpmmSwap`);
        }
        const [btokenA, bTokenB, _quoter, lp] = (0, utils_1.parseStructTag)(extra.poolStructTag).typeParams;
        const [lendingMarket, coinTypeA, _bTokenA] = (0, utils_1.parseStructTag)(extra.bankAStructTag).typeParams;
        const [_lendingMarket, coinTypeB, _bTokenB] = (0, utils_1.parseStructTag)(extra.bankBStructTag).typeParams;
        const [coinX, _coinY] = this.swapInfo.pool.allTokens;
        const xToY = coinX.address === this.swapInfo.assetIn;
        const coinA = xToY
            ? this.inputCoinObject
            : sui_1.SuiUtils.zeroCoin(tx, (0, utils_1.normalizeStructTag)(coinTypeA));
        const coinB = !xToY
            ? this.inputCoinObject
            : sui_1.SuiUtils.zeroCoin(tx, (0, utils_1.normalizeStructTag)(coinTypeB));
        const bankATypeArgs = [lendingMarket, coinTypeA, btokenA].map(utils_1.normalizeStructTag);
        const bankBTypeArgs = [lendingMarket, coinTypeB, bTokenB].map(utils_1.normalizeStructTag);
        const bankInTypeArgs = xToY ? bankATypeArgs : bankBTypeArgs;
        const bankOutTypeArgs = xToY ? bankBTypeArgs : bankATypeArgs;
        // mint btoken from both coins
        const bTokenIn = tx.moveCall({
            target: `${this.config.steamm.package}::bank::mint_btokens`,
            typeArguments: bankInTypeArgs,
            arguments: [
                tx.object(xToY ? extra.bankA : extra.bankB),
                tx.object(extra.lendingMarketA),
                xToY ? coinA : coinB,
                this.getInputCoinValue(tx),
                tx.object(utils_1.SUI_CLOCK_OBJECT_ID),
            ],
        });
        const bTokenOut = sui_1.SuiUtils.zeroCoin(tx, (0, utils_1.normalizeStructTag)(xToY ? bTokenB : btokenA));
        // call swap on btoken
        tx.moveCall({
            target: `${this.config.steamm.package}::cpmm::swap`,
            typeArguments: [btokenA, bTokenB, lp].map(utils_1.normalizeStructTag),
            arguments: [
                tx.object(this.swapInfo.poolId),
                xToY ? bTokenIn : bTokenOut,
                xToY ? bTokenOut : bTokenIn,
                tx.pure.bool(xToY),
                sui_1.SuiUtils.getCoinValue((0, utils_1.normalizeStructTag)(xToY ? btokenA : bTokenB), bTokenIn, tx),
                tx.pure.u64(0), // min output
            ],
        });
        // burn btoken to get out coin
        const [outCoin] = tx.moveCall({
            target: `${this.config.steamm.package}::bank::burn_btokens`,
            typeArguments: bankOutTypeArgs,
            arguments: [
                tx.object(xToY ? extra.bankB : extra.bankA),
                tx.object(extra.lendingMarketA),
                bTokenOut,
                sui_1.SuiUtils.getCoinValue((0, utils_1.normalizeStructTag)(xToY ? bTokenB : btokenA), bTokenOut, tx),
                tx.object(utils_1.SUI_CLOCK_OBJECT_ID),
            ],
        });
        const coinIn = xToY ? coinA : coinB;
        const coinOut = xToY ? coinB : coinA;
        // the coinIn was mutated by mint_btokens above, but not consumed, so we need to transfer or destroy it
        sui_1.SuiUtils.transferOrDestroyZeroCoin(tx, this.swapInfo.assetIn, coinIn, this.currentAccount);
        // bTokenIn was mutated by cpmm::swap above, but not consumed, so we need to transfer or destroy it
        sui_1.SuiUtils.transferOrDestroyZeroCoin(tx, (0, utils_1.normalizeStructTag)(xToY ? btokenA : bTokenB), bTokenIn, this.currentAccount);
        // bTokenOut was burned by burn_btokens above, but not consumed, so we need to transfer or destroy it
        sui_1.SuiUtils.transferOrDestroyZeroCoin(tx, (0, utils_1.normalizeStructTag)(xToY ? bTokenB : btokenA), bTokenOut, this.currentAccount);
        // after all we need to merge the placeholder output coin (zero) with actual output coin from swap burn
        tx.mergeCoins(coinOut, [outCoin]);
        return coinOut;
    }
}
exports.SteammContract = SteammContract;
