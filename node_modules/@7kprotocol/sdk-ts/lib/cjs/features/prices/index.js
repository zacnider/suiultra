"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.PRICES_API = void 0;
exports.getTokenPrice = getTokenPrice;
exports.getTokenPrices = getTokenPrices;
exports.getSuiPrice = getSuiPrice;
const tokens_1 = require("../../constants/tokens");
const token_1 = require("../../utils/token");
exports.PRICES_API = "https://prices.7k.ag";
function getTokenPrice(id_1) {
    return __awaiter(this, arguments, void 0, function* (id, vsCoin = tokens_1.NATIVE_USDC_TOKEN_TYPE) {
        var _a;
        try {
            const response = yield fetch(`${exports.PRICES_API}/price?ids=${(0, token_1.normalizeTokenType)(id)}&vsCoin=${vsCoin}`);
            const pricesRes = (yield response.json());
            return Number(((_a = pricesRes === null || pricesRes === void 0 ? void 0 : pricesRes[id]) === null || _a === void 0 ? void 0 : _a.price) || 0);
        }
        catch (_) {
            return 0;
        }
    });
}
const chunkArray = (array, chunkSize) => {
    const chunks = [];
    for (let i = 0; i < array.length; i += chunkSize) {
        chunks.push(array.slice(i, i + chunkSize));
    }
    return chunks;
};
const MAX_TOTAL_IDS = 500;
const MAX_IDS_PER_REQUEST = 100;
function getTokenPrices(ids_1) {
    return __awaiter(this, arguments, void 0, function* (ids, vsCoin = tokens_1.NATIVE_USDC_TOKEN_TYPE) {
        try {
            const limitedIds = ids.slice(0, MAX_TOTAL_IDS).map(token_1.normalizeTokenType);
            const idChunks = chunkArray(limitedIds, MAX_IDS_PER_REQUEST);
            const responses = yield Promise.all(idChunks.map((chunk) => __awaiter(this, void 0, void 0, function* () {
                const response = yield fetch(`${exports.PRICES_API}/price`, {
                    method: "POST",
                    headers: {
                        "Content-Type": "application/json",
                    },
                    body: JSON.stringify({
                        ids: chunk,
                        vsCoin,
                    }),
                });
                const pricesRes = (yield response.json());
                return pricesRes;
            })));
            const combinedPrices = responses.reduce((acc, pricesRes) => {
                Object.keys(pricesRes).forEach((id) => {
                    var _a;
                    acc[id] = Number(((_a = pricesRes[id]) === null || _a === void 0 ? void 0 : _a.price) || 0);
                });
                return acc;
            }, {});
            const finalPrices = limitedIds.reduce((acc, id) => {
                acc[id] = combinedPrices[id] || 0;
                return acc;
            }, {});
            return finalPrices;
        }
        catch (_) {
            return ids.slice(0, MAX_TOTAL_IDS).reduce((acc, id) => {
                acc[id] = 0;
                return acc;
            }, {});
        }
    });
}
function getSuiPrice() {
    return __awaiter(this, void 0, void 0, function* () {
        return yield getTokenPrice(tokens_1.SUI_FULL_TYPE);
    });
}
