import { parseStructTag } from "../../utils/sui-types.js";
import {
  batch,
  findNamesInTransaction,
  getFirstLevelNamedTypes,
  populateNamedTypesFromCache,
  replaceNames
} from "./utils.js";
const namedPackagesPlugin = ({
  url,
  pageSize = 50,
  overrides = { packages: {}, types: {} }
}) => {
  Object.keys(overrides.types).forEach((type) => {
    if (parseStructTag(type).typeParams.length > 0)
      throw new Error(
        "Type overrides must be first-level only. If you want to supply generic types, just pass each type individually."
      );
  });
  const cache = overrides;
  return async (transactionData, _buildOptions, next) => {
    const names = findNamesInTransaction(transactionData);
    const [packages, types] = await Promise.all([
      resolvePackages(
        names.packages.filter((x) => !cache.packages[x]),
        url,
        pageSize
      ),
      resolveTypes(
        [...getFirstLevelNamedTypes(names.types)].filter((x) => !cache.types[x]),
        url,
        pageSize
      )
    ]);
    Object.assign(cache.packages, packages);
    Object.assign(cache.types, types);
    const composedTypes = populateNamedTypesFromCache(names.types, cache.types);
    replaceNames(transactionData, {
      packages: { ...cache.packages },
      // we include the "composed" type cache too.
      types: composedTypes
    });
    await next();
  };
  async function resolvePackages(packages, apiUrl, pageSize2) {
    if (packages.length === 0) return {};
    const batches = batch(packages, pageSize2);
    const results = {};
    await Promise.all(
      batches.map(async (batch2) => {
        const response = await fetch(`${apiUrl}/v1/resolution/bulk`, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({
            names: batch2
          })
        });
        if (!response.ok) {
          const errorBody = await response.json().catch(() => ({}));
          throw new Error(`Failed to resolve packages: ${errorBody?.message}`);
        }
        const data = await response.json();
        if (!data?.resolution) return;
        for (const pkg of Object.keys(data?.resolution)) {
          const pkgData = data.resolution[pkg]?.package_id;
          if (!pkgData) continue;
          results[pkg] = pkgData;
        }
      })
    );
    return results;
  }
  async function resolveTypes(types, apiUrl, pageSize2) {
    if (types.length === 0) return {};
    const batches = batch(types, pageSize2);
    const results = {};
    await Promise.all(
      batches.map(async (batch2) => {
        const response = await fetch(`${apiUrl}/v1/struct-definition/bulk`, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({
            types: batch2
          })
        });
        if (!response.ok) {
          const errorBody = await response.json().catch(() => ({}));
          throw new Error(`Failed to resolve types: ${errorBody?.message}`);
        }
        const data = await response.json();
        if (!data?.resolution) return;
        for (const type of Object.keys(data?.resolution)) {
          const typeData = data.resolution[type]?.type_tag;
          if (!typeData) continue;
          results[type] = typeData;
        }
      })
    );
    return results;
  }
};
export {
  namedPackagesPlugin
};
//# sourceMappingURL=NamedPackagesPlugin.js.map
