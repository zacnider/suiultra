"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var NamedPackagesPlugin_exports = {};
__export(NamedPackagesPlugin_exports, {
  namedPackagesPlugin: () => namedPackagesPlugin
});
module.exports = __toCommonJS(NamedPackagesPlugin_exports);
var import_sui_types = require("../../utils/sui-types.js");
var import_utils = require("./utils.js");
const namedPackagesPlugin = ({
  url,
  pageSize = 50,
  overrides = { packages: {}, types: {} }
}) => {
  Object.keys(overrides.types).forEach((type) => {
    if ((0, import_sui_types.parseStructTag)(type).typeParams.length > 0)
      throw new Error(
        "Type overrides must be first-level only. If you want to supply generic types, just pass each type individually."
      );
  });
  const cache = overrides;
  return async (transactionData, _buildOptions, next) => {
    const names = (0, import_utils.findNamesInTransaction)(transactionData);
    const [packages, types] = await Promise.all([
      resolvePackages(
        names.packages.filter((x) => !cache.packages[x]),
        url,
        pageSize
      ),
      resolveTypes(
        [...(0, import_utils.getFirstLevelNamedTypes)(names.types)].filter((x) => !cache.types[x]),
        url,
        pageSize
      )
    ]);
    Object.assign(cache.packages, packages);
    Object.assign(cache.types, types);
    const composedTypes = (0, import_utils.populateNamedTypesFromCache)(names.types, cache.types);
    (0, import_utils.replaceNames)(transactionData, {
      packages: { ...cache.packages },
      // we include the "composed" type cache too.
      types: composedTypes
    });
    await next();
  };
  async function resolvePackages(packages, apiUrl, pageSize2) {
    if (packages.length === 0) return {};
    const batches = (0, import_utils.batch)(packages, pageSize2);
    const results = {};
    await Promise.all(
      batches.map(async (batch2) => {
        const response = await fetch(`${apiUrl}/v1/resolution/bulk`, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({
            names: batch2
          })
        });
        if (!response.ok) {
          const errorBody = await response.json().catch(() => ({}));
          throw new Error(`Failed to resolve packages: ${errorBody?.message}`);
        }
        const data = await response.json();
        if (!data?.resolution) return;
        for (const pkg of Object.keys(data?.resolution)) {
          const pkgData = data.resolution[pkg]?.package_id;
          if (!pkgData) continue;
          results[pkg] = pkgData;
        }
      })
    );
    return results;
  }
  async function resolveTypes(types, apiUrl, pageSize2) {
    if (types.length === 0) return {};
    const batches = (0, import_utils.batch)(types, pageSize2);
    const results = {};
    await Promise.all(
      batches.map(async (batch2) => {
        const response = await fetch(`${apiUrl}/v1/struct-definition/bulk`, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({
            types: batch2
          })
        });
        if (!response.ok) {
          const errorBody = await response.json().catch(() => ({}));
          throw new Error(`Failed to resolve types: ${errorBody?.message}`);
        }
        const data = await response.json();
        if (!data?.resolution) return;
        for (const type of Object.keys(data?.resolution)) {
          const typeData = data.resolution[type]?.type_tag;
          if (!typeData) continue;
          results[type] = typeData;
        }
      })
    );
    return results;
  }
};
//# sourceMappingURL=NamedPackagesPlugin.js.map
