{
  "version": 3,
  "sources": ["../../../../src/transactions/plugins/utils.ts"],
  "sourcesContent": ["// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { isValidNamedPackage, isValidNamedType } from '../../utils/move-registry.js';\nimport { normalizeStructTag, parseStructTag } from '../../utils/sui-types.js';\nimport type { StructTag } from '../../utils/sui-types.js';\nimport type { TransactionDataBuilder } from '../TransactionData.js';\n\nexport type NamedPackagesPluginCache = {\n\tpackages: Record<string, string>;\n\ttypes: Record<string, string>;\n};\n\nconst NAME_SEPARATOR = '/';\n\nexport type NameResolutionRequest = {\n\tid: number;\n\ttype: 'package' | 'moveType';\n\tname: string;\n};\n\n/**\n * Looks up all `.move` names in a transaction block.\n * Returns a list of all the names found.\n */\nexport function findNamesInTransaction(builder: TransactionDataBuilder): {\n\tpackages: string[];\n\ttypes: string[];\n} {\n\tconst packages: Set<string> = new Set();\n\tconst types: Set<string> = new Set();\n\n\tfor (const command of builder.commands) {\n\t\tif (command.MakeMoveVec?.type) {\n\t\t\tgetNamesFromTypeList([command.MakeMoveVec.type]).forEach((type) => {\n\t\t\t\ttypes.add(type);\n\t\t\t});\n\t\t\tcontinue;\n\t\t}\n\t\tif (!('MoveCall' in command)) continue;\n\t\tconst tx = command.MoveCall;\n\n\t\tif (!tx) continue;\n\n\t\tconst pkg = tx.package.split('::')[0];\n\t\tif (hasMvrName(pkg)) {\n\t\t\tif (!isValidNamedPackage(pkg)) throw new Error(`Invalid package name: ${pkg}`);\n\t\t\tpackages.add(pkg);\n\t\t}\n\n\t\tgetNamesFromTypeList(tx.typeArguments ?? []).forEach((type) => {\n\t\t\ttypes.add(type);\n\t\t});\n\t}\n\n\treturn {\n\t\tpackages: [...packages],\n\t\ttypes: [...types],\n\t};\n}\n\n/**\n * Extracts all first-level types from a list of types.\n * E.g. for the input `['@mvr/demo::a::A<@mvr/demo::b::B>']`,\n * the output will be `['@mvr/demo::a::A', '@mvr/demo::b::B']`.\n */\nexport function getFirstLevelNamedTypes(types: string[]) {\n\tconst results: Set<string> = new Set();\n\n\tfor (const type of types) {\n\t\tfindMvrNames(type).forEach((name) => results.add(name));\n\t}\n\n\treturn results;\n}\n\n/**\n * Extracts all named types from a given type.\n */\nfunction findMvrNames(type: string | StructTag) {\n\tconst types: Set<string> = new Set();\n\n\tif (typeof type === 'string' && !hasMvrName(type)) return types;\n\n\tlet tag = isStructTag(type) ? type : parseStructTag(type);\n\n\tif (hasMvrName(tag.address)) types.add(`${tag.address}::${tag.module}::${tag.name}`);\n\n\tfor (const param of tag.typeParams) {\n\t\tfindMvrNames(param).forEach((name) => types.add(name));\n\t}\n\n\treturn types;\n}\n\n// /**\n//  * Allows partial replacements of known types with their resolved equivalents.\n//  * E.g. `@mvr/demo::a::A<@mvr/demo::b::B>` can be resolved, if we already have\n//  * the address for `@mvr/demo::b::B` and the address for `@mvr/demo::a::A`,\n//  * without the need to have the full type in the cache.\n//  *\n//  * Returns the fully composed resolved types (if any) in a `named-type -> normalized-type` map.\n//  */\nexport function populateNamedTypesFromCache(types: string[], typeCache: Record<string, string>) {\n\tconst composedTypes: Record<string, string> = {};\n\n\ttypes.forEach((type) => {\n\t\tconst normalized = normalizeStructTag(findAndReplaceCachedTypes(type, typeCache));\n\t\tcomposedTypes[type] = normalized;\n\t});\n\n\treturn composedTypes;\n}\n\n/**\n * Traverses a type, and replaces any found names with their resolved equivalents,\n * based on the supplied type cache.\n */\nfunction findAndReplaceCachedTypes(\n\ttag: string | StructTag,\n\ttypeCache: Record<string, string>,\n): StructTag {\n\tconst type = isStructTag(tag) ? tag : parseStructTag(tag);\n\n\tlet typeTag = `${type.address}::${type.module}::${type.name}`;\n\tconst cacheHit = typeCache[typeTag];\n\n\treturn {\n\t\t...type,\n\t\taddress: cacheHit ? cacheHit.split('::')[0] : type.address,\n\t\ttypeParams: type.typeParams.map((param) => findAndReplaceCachedTypes(param, typeCache)),\n\t};\n}\n\n/**\n * Replace all names & types in a transaction block\n * with their resolved names/types.\n */\nexport function replaceNames(builder: TransactionDataBuilder, cache: NamedPackagesPluginCache) {\n\tfor (const command of builder.commands) {\n\t\t// Replacements for `MakeMoveVec` commands (that can include types)\n\t\tif (command.MakeMoveVec?.type) {\n\t\t\tif (!hasMvrName(command.MakeMoveVec.type)) continue;\n\t\t\tif (!cache.types[command.MakeMoveVec.type])\n\t\t\t\tthrow new Error(`No resolution found for type: ${command.MakeMoveVec.type}`);\n\t\t\tcommand.MakeMoveVec.type = cache.types[command.MakeMoveVec.type];\n\t\t}\n\t\t// Replacements for `MoveCall` commands (that can include packages & types)\n\t\tconst tx = command.MoveCall;\n\t\tif (!tx) continue;\n\n\t\tconst nameParts = tx.package.split('::');\n\t\tconst name = nameParts[0];\n\n\t\tif (hasMvrName(name) && !cache.packages[name])\n\t\t\tthrow new Error(`No address found for package: ${name}`);\n\n\t\t// Replace package name with address.\n\t\tif (hasMvrName(name)) {\n\t\t\tnameParts[0] = cache.packages[name];\n\t\t\ttx.package = nameParts.join('::');\n\t\t}\n\n\t\tconst types = tx.typeArguments;\n\t\tif (!types) continue;\n\n\t\tfor (let i = 0; i < types.length; i++) {\n\t\t\tif (!hasMvrName(types[i])) continue;\n\n\t\t\tif (!cache.types[types[i]]) throw new Error(`No resolution found for type: ${types[i]}`);\n\t\t\ttypes[i] = cache.types[types[i]];\n\t\t}\n\n\t\ttx.typeArguments = types;\n\t}\n}\n\nexport function batch<T>(arr: T[], size: number): T[][] {\n\tconst batches = [];\n\tfor (let i = 0; i < arr.length; i += size) {\n\t\tbatches.push(arr.slice(i, i + size));\n\t}\n\treturn batches;\n}\n\n/**\n * Returns a list of unique types that include a name\n * from the given list. This list is retrieved from the Transaction Data.\n */\nfunction getNamesFromTypeList(types: string[]) {\n\tconst names = new Set<string>();\n\tfor (const type of types) {\n\t\tif (hasMvrName(type)) {\n\t\t\tif (!isValidNamedType(type)) throw new Error(`Invalid type with names: ${type}`);\n\t\t\tnames.add(type);\n\t\t}\n\t}\n\treturn names;\n}\n\nfunction hasMvrName(nameOrType: string) {\n\treturn (\n\t\tnameOrType.includes(NAME_SEPARATOR) || nameOrType.includes('@') || nameOrType.includes('.sui')\n\t);\n}\n\nfunction isStructTag(type: string | StructTag): type is StructTag {\n\treturn (\n\t\ttypeof type === 'object' &&\n\t\t'address' in type &&\n\t\t'module' in type &&\n\t\t'name' in type &&\n\t\t'typeParams' in type\n\t);\n}\n"],
  "mappings": "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",
  "names": []
}
