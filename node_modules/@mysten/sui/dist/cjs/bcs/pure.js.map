{
  "version": 3,
  "sources": ["../../../src/bcs/pure.ts"],
  "sourcesContent": ["// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { bcs } from '@mysten/bcs';\nimport type { BcsType } from '@mysten/bcs';\n\nimport { Address } from './bcs.js';\n\nexport type BasePureType =\n\t| 'u8'\n\t| 'u16'\n\t| 'u32'\n\t| 'u64'\n\t| 'u128'\n\t| 'u256'\n\t| 'bool'\n\t| 'id'\n\t| 'string'\n\t| 'address';\n\ninterface PureShapeByType {\n\tu8: number;\n\tu16: number;\n\tu32: number;\n\tu64: bigint | string | number;\n\tu128: bigint | string | number;\n\tu256: bigint | string | number;\n\tbool: boolean;\n\tstring: string;\n\tid: string | Uint8Array;\n\taddress: string | Uint8Array;\n}\n\nexport type PureTypeName = BasePureType | `vector<${string}>` | `option<${string}>`;\nexport type ValidPureTypeName<T extends string> = T extends BasePureType\n\t? PureTypeName\n\t: T extends `vector<${infer U}>`\n\t\t? ValidPureTypeName<U>\n\t\t: T extends `option<${infer U}>`\n\t\t\t? ValidPureTypeName<U>\n\t\t\t: PureTypeValidationError<T>;\n\nexport type ShapeFromPureTypeName<T extends PureTypeName> = T extends BasePureType\n\t? PureShapeByType[T]\n\t: T extends `vector<${infer U extends PureTypeName}>`\n\t\t? ShapeFromPureTypeName<U>[]\n\t\t: T extends `option<${infer U extends PureTypeName}>`\n\t\t\t? ShapeFromPureTypeName<U> | null\n\t\t\t: never;\n\ntype PureTypeValidationError<T extends string> = T & {\n\terror: `Invalid Pure type name: ${T}`;\n};\n\nexport function pureBcsSchemaFromTypeName<T extends PureTypeName>(\n\tname: T extends PureTypeName ? ValidPureTypeName<T> : T,\n): BcsType<ShapeFromPureTypeName<T>> {\n\tswitch (name) {\n\t\tcase 'u8':\n\t\t\treturn bcs.u8() as never;\n\t\tcase 'u16':\n\t\t\treturn bcs.u16() as never;\n\t\tcase 'u32':\n\t\t\treturn bcs.u32() as never;\n\t\tcase 'u64':\n\t\t\treturn bcs.u64() as never;\n\t\tcase 'u128':\n\t\t\treturn bcs.u128() as never;\n\t\tcase 'u256':\n\t\t\treturn bcs.u256() as never;\n\t\tcase 'bool':\n\t\t\treturn bcs.bool() as never;\n\t\tcase 'string':\n\t\t\treturn bcs.string() as never;\n\t\tcase 'id':\n\t\tcase 'address':\n\t\t\treturn Address as never;\n\t}\n\n\tconst generic = name.match(/^(vector|option)<(.+)>$/);\n\tif (generic) {\n\t\tconst [kind, inner] = generic.slice(1);\n\t\tif (kind === 'vector') {\n\t\t\treturn bcs.vector(pureBcsSchemaFromTypeName(inner as PureTypeName)) as never;\n\t\t} else {\n\t\t\treturn bcs.option(pureBcsSchemaFromTypeName(inner as PureTypeName)) as never;\n\t\t}\n\t}\n\n\tthrow new Error(`Invalid Pure type name: ${name}`);\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA,iBAAoB;AAGpB,IAAAA,cAAwB;AAgDjB,SAAS,0BACf,MACoC;AACpC,UAAQ,MAAM;AAAA,IACb,KAAK;AACJ,aAAO,eAAI,GAAG;AAAA,IACf,KAAK;AACJ,aAAO,eAAI,IAAI;AAAA,IAChB,KAAK;AACJ,aAAO,eAAI,IAAI;AAAA,IAChB,KAAK;AACJ,aAAO,eAAI,IAAI;AAAA,IAChB,KAAK;AACJ,aAAO,eAAI,KAAK;AAAA,IACjB,KAAK;AACJ,aAAO,eAAI,KAAK;AAAA,IACjB,KAAK;AACJ,aAAO,eAAI,KAAK;AAAA,IACjB,KAAK;AACJ,aAAO,eAAI,OAAO;AAAA,IACnB,KAAK;AAAA,IACL,KAAK;AACJ,aAAO;AAAA,EACT;AAEA,QAAM,UAAU,KAAK,MAAM,yBAAyB;AACpD,MAAI,SAAS;AACZ,UAAM,CAAC,MAAM,KAAK,IAAI,QAAQ,MAAM,CAAC;AACrC,QAAI,SAAS,UAAU;AACtB,aAAO,eAAI,OAAO,0BAA0B,KAAqB,CAAC;AAAA,IACnE,OAAO;AACN,aAAO,eAAI,OAAO,0BAA0B,KAAqB,CAAC;AAAA,IACnE;AAAA,EACD;AAEA,QAAM,IAAI,MAAM,2BAA2B,IAAI,EAAE;AAClD;",
  "names": ["import_bcs"]
}
